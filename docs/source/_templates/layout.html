{# Import the theme's layout. #} {% extends '!layout.html' %} {%- block extrahead %} {% if not git.github %}
<link rel="stylesheet" href="./MystEditor.css" />
<link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet" />
<script type="module">
  import { MystEditorGit, defaultButtons, effect } from "./MystEditor.js";

  // Get neccessary values from Sphinx conf.py
  const config = {
    repoUrl: "{{ config.repo_url }}",
    repoName: "{{ config.repo_name }}",
    editUrl: "{{ page.edit_url }}",
    git: {
      docsRoot: "{{ git.docs_root }}",
    },
    baseUrl: null,
    apiUrl: null,
    filePath: null,
    projectPath: null,
    defaultBranch: null,
  };
  config.baseUrl = config.repoUrl.slice(0, config.repoUrl.indexOf("/git/") + 4);
  config.apiUrl = config.baseUrl + "/api/v4";
  config.filePath = config.editUrl.slice(config.editUrl.indexOf("raw/") + 4); // file path with branch
  config.filePath = config.filePath.slice(config.filePath.indexOf("/") + 1);
  config.projectPath = encodeURIComponent(config.repoUrl.slice(config.repoUrl.indexOf("/git/") + 5));

  async function getGitlabCsrf() {
    const response = await fetch(config.baseUrl);
    if (!response.ok) {
      return "";
    }
    const parser = new DOMParser();
    const html = parser.parseFromString(await response.text(), "text/html");
    return html.querySelector("meta[name=csrf-token]").content;
  }

  async function getDefaultBranch() {
    try {
      const response = await fetch(`${config.apiUrl}/projects/${config.projectPath}`);
      if (!response.ok) {
        return undefined;
      }
      const data = await response.json();
      return data.default_branch;
    } catch (error) {
      console.error(error);
      return undefined;
    }
  }

  async function openMyst(initialRoom) {
    // disable Sphinx navigation shortcuts (like s, n, p)
    window.addEventListener("keydown", (ev) => ev.stopImmediatePropagation(), { capture: true });

    const userData = await (await fetch(`${config.apiUrl}/user`)).json();
    const username = userData.username;
    const stringToColor = (str) => {
      let hash = 0;
      str.split("").forEach((char) => {
        hash = char.charCodeAt(0) + ((hash << 5) - hash);
      });
      let color = "#";
      for (let i = 0; i < 3; i++) {
        const value = (hash >> (i * 8)) & 0xff;
        color += value.toString(16).padStart(2, "0");
      }
      return color;
    };

    config.defaultBranch = await getDefaultBranch();

    const commitButton = {
      text: "Commit",
      action: commitChanges,
    };

    const mainContainer = document.querySelector("main.md-main");
    mainContainer.innerHTML = "";
    mainContainer.style.height = "calc(100vh - 60px)";

    const branches = await getBranches(1);
    // ensure default branch is there
    if (!branches.includes(config.defaultBranch)) {
      branches.unshift(config.defaultBranch);
    }
   
    const styles = new CSSStyleSheet();
    styles.replaceSync(`
      .myst-main-editor {
        font-size: 14px !important;
      }
    `);
    let changeHistory = localStorage.getItem(`myst/${config.repoName}/history`);
    changeHistory = changeHistory ? JSON.parse(changeHistory) : [];
    const storeHistory = (history) => {
      localStorage.setItem(`myst/${config.repoName}/history`, JSON.stringify(history));
    };
   
    const initialState = initialRoom ? {
      commit: { hash: initialRoom.split("/")[1], message: await getCommitMessage(initialRoom.split("/")[1]) },
      file: decodeURIComponent(initialRoom.split("/")[2]),
      branch: decodeURIComponent(initialRoom.split("/")[3])
    } : null;

    MystEditorGit(
      {
        repo: config.projectPath,
        initialBranches: branches,
        getBranches,
        searchBranches,
        getCommits,
        searchCommits,
        getFiles,
        getText,
        additionalStyles: styles,
        storeHistory,
        initialState,
        initialHistory: changeHistory,
        collaboration: {
          enabled: true,
          commentsEnabled: true,
          wsUrl: "/devsignal",
          resolvingCommentsEnabled: true,
          username,
          color: stringToColor(username),
        },
        getAvatar: (login) => `/users/${login}.png`,
        title: config.repoName,
        includeButtons: defaultButtons,
        syncScroll: true,
        id: "sphinx",
      },
      mainContainer,
    );

    function setupHooks() {
      if (!window.myst_editor.sphinx.git) {
        setTimeout(setupHooks, 10);
        return;
      }

      effect(() => {
        if (window.myst_editor.sphinx.git.commit.value == window.myst_editor.sphinx.git.commits.value[0]) {
          window.myst_editor.sphinx.state.options.includeButtons.value = [...defaultButtons, commitButton];
        } else {
          window.myst_editor.sphinx.state.options.includeButtons.value = defaultButtons;
        }
      });
      
      effect(() => {
        const room = window.myst_editor.sphinx.git.room.value;
        const branch = window.myst_editor.sphinx.git.branch.value; 
        if (room) {
          const edit =`?edit=${encodeURIComponent(room) + encodeURIComponent(`/${branch}`)}`;
          window.history.pushState(null, null, edit);
        }
      });
    }
    setupHooks();
  }

  const editBtn = document.querySelector(`a[href="{{ page.edit_url }}"]`);
  if (editBtn) {
    editBtn.onclick = (ev) => {
      ev.preventDefault();
      openMyst();
    }
  }
  window.onload = () => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("edit")) {
      openMyst(urlParams.get('edit'));
    }
  };

  async function getBranches(page) {
    try {
      const response = await fetch(`${config.apiUrl}/projects/${config.projectPath}/repository/branches?page=${page}&per_page=10&sort=updated_desc`);
      if (!response.ok) {
        return [];
      }
      const branches = await response.json();

      let result = branches.map((b) => b.name);
      // default branch will always be part of the first page
      if (page != 1) {
        result = result.filter((b) => b != config.defaultBranch);
      }

      // ensure default branch is the first branch
      const defaultIdx = result.indexOf(config.defaultBranch);
      if (defaultIdx != -1) {
        result.splice(defaultIdx, 1);
        result.unshift(config.defaultBranch);
      }
      return result;
    } catch (err) {
      console.error(err);
      return [];
    }
  }

  async function searchBranches(input) {
    try {
      const response = await fetch(
        `${config.apiUrl}/projects/${config.projectPath}/repository/branches?per_page=10&search=${encodeURIComponent(input)}&sort=updated_desc`,
      );
      if (!response.ok) {
        return [];
      }
      const branches = await response.json();

      return branches.map((b) => b.name);
    } catch (err) {
      console.error(err);
      return [];
    }
  }

  async function getCommits(branch, page) {
    try {
      const response = await fetch(
        `${config.apiUrl}/projects/${config.projectPath}/repository/commits?ref_name=${encodeURIComponent(branch)}&page=${page}&per_page=10`,
      );
      if (!response.ok) {
        return [];
      }
      const commits = await response.json();

      return commits.map((c) => {
        let firstMsgLineEndIdx = c.message.indexOf("\n");
        if (firstMsgLineEndIdx == -1) firstMsgLineEndIdx = c.message.length;
        const firstMsgLine = c.message.slice(0, firstMsgLineEndIdx);
        return { hash: c.short_id, message: firstMsgLine };
      });
    } catch (error) {
      console.error(error);
      return [];
    }
  }

  async function searchCommits(input, branch) {
    try {
      const response = await fetch(
        `${config.apiUrl}/projects/${config.projectPath}/search?scope=commits&ref=${encodeURIComponent(branch)}&per_page=10&search=${encodeURIComponent(input)}`,
      );
      if (!response.ok) {
        return [];
      }
      const commits = await response.json();

      return commits.map((c) => {
        let firstMsgLineEndIdx = c.message.indexOf("\n");
        if (firstMsgLineEndIdx == -1) firstMsgLineEndIdx = c.message.length;
        const firstMsgLine = c.message.slice(0, firstMsgLineEndIdx);
        return { hash: c.short_id, message: firstMsgLine };
      });
    } catch (error) {
      console.error(error);
      return [];
    }
  }
  
  async function getCommitMessage(shortHash) {
    try {
      const response = await fetch(`${config.apiUrl}/projects/${config.projectPath}/repository/commits/${shortHash}`);
      if (!response.ok) {
        return "";
      }
      const data = await response.json();
      return data.message.split("\n")[0];
    } catch (error) {
      console.error(error)
      return "";
    }
  }

  // loads all files in docs
  async function getFiles(branch, commit) {
    const allFiles = [];
    let page = 1;
    while (true) {
      try {
        const response = await fetch(
          `${config.apiUrl}/projects/${config.projectPath}/repository/tree?path=${encodeURIComponent(config.git.docsRoot)}&recursive=true&ref=${commit.hash}&page=${page}&per_page=100`,
        );
        if (!response.ok) {
          break;
        }
        const files = await response.json();
        if (files.length == 0) {
          break;
        }

        allFiles.push(...files);
        page++;
      } catch (error) {
        console.error(error);
        break;
      }
    }

    const result = allFiles.filter((f) => f.type == "blob" && f.name.endsWith(".md")).map((f) => f.path);
    // ensure the current page is the top file
    const currentPageIdx = result.indexOf(config.filePath);
    if (currentPageIdx != -1) {
      [result[0], result[currentPageIdx]] = [result[currentPageIdx], result[0]];
    }
    return result;
  }

  async function getText(branch, commit, file) {
    try {
      const response = await fetch(
        `${config.apiUrl}/projects/${config.projectPath}/repository/files/${encodeURIComponent(file)}/raw?ref=${commit.hash}`,
      );
      if (!response.ok) {
        return "";
      }
      const content = await response.text();
      return content;
    } catch (err) {
      console.error(err);
      return "";
    }
  }

  async function commitChanges() {
    const csrf = await getGitlabCsrf();

    await fetch(`${config.apiUrl}/projects/${config.projectPath}/repository/commits`, {
      method: "POST",
      headers: { "X-CSRF-TOKEN": csrf, "Content-Type": "application/json" },
      body: JSON.stringify({
        branch: window.myst_editor.sphinx.git.branch.value,
        commit_message: `MyST: update docs ${window.myst_editor.sphinx.git.file.value}`,
        actions: [
          {
            action: "update",
            file_path: window.myst_editor.sphinx.git.file.value,
            content: window.myst_editor.sphinx.text,
          },
        ],
      }),
    });
  }
</script>
{% endif %} {{ super() }} {%- endblock %}
